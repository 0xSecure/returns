- case: functor_inheritance_correct
  disable_cache: true
  main: |
    from typing import Callable, TypeVar
    from returns.typeclasses.functor import Functor
    from returns.hkt import Kind

    V = TypeVar('V')
    N = TypeVar('N')

    class MyClass(Kind['MyClass', V], Functor[V]):
        def __init__(self, value: V) -> None:
            self.value = value

        def map(self, function: Callable[[V], N]) -> 'MyClass[N]':
            return MyClass(function(self.value))

    reveal_type(MyClass('1').map(int))  # N: Revealed type is 'main.MyClass[builtins.int*]'


- case: functor_inheritance_correct2
  disable_cache: true
  main: |
    from typing import Callable, TypeVar
    from returns.typeclasses.functor import Functor
    from returns.hkt import Kind

    V = TypeVar('V')
    E = TypeVar('E')
    N = TypeVar('N')

    class MyClass(Kind['MyClass', V, E], Functor[V]):
        def __init__(self, value: V, error: E) -> None:
            self.value = value
            self.error = error

        def map(self, function: Callable[[V], N]) -> 'MyClass[N, E]':
            return MyClass(function(self.value), self.error)

    reveal_type(MyClass('1', 1).map(int))  # N: Revealed type is 'main.MyClass[builtins.int*, builtins.int]'


- case: functor_inheritance_missing
  disable_cache: true
  main: |
    from typing import Callable, TypeVar
    from returns.typeclasses.functor import Functor
    from returns.hkt import Kind

    V = TypeVar('V')
    N = TypeVar('N')

    class MyClass(Kind['MyClass', V], Functor[V]):
        def __init__(self, value: V) -> None:
            self.value = value

    reveal_type(MyClass('1').map(int))
  out: |
    main:12: error: Cannot instantiate abstract class 'MyClass' with abstract attribute 'map'
    main:12: note: Revealed type is 'returns.hkt.Kind[main.MyClass[builtins.str], builtins.int*]'


- case: functor_inheritance_wrong
  disable_cache: true
  main: |
    from typing import Callable, TypeVar
    from returns.typeclasses.functor import Functor
    from returns.hkt import Kind

    V = TypeVar('V')
    N = TypeVar('N')

    class MyClass(Kind['MyClass', V], Functor[V]):
        def __init__(self, value: V) -> None:
            self.value = value

        # Breaks the contract
        def map(self, function: Callable[[V], N]) -> 'MyClass[V]':
            return MyClass(self.value)
  out: |
    main:13: error: Return type "MyClass[V]" of "map" incompatible with return type "Kind[MyClass[V], _NewValueType]" in supertype "Functor"


- case: functor_inheritance_wrong2
  disable_cache: true
  main: |
    from typing import Callable, TypeVar
    from returns.typeclasses.functor import Functor
    from returns.hkt import Kind

    V = TypeVar('V')
    E = TypeVar('E')
    N = TypeVar('N')

    class MyClass(Kind['MyClass', V, E], Functor[V]):
        def __init__(self, value: V, error: E) -> None:
            self.value = value
            self.error = error

        def map(self, function: Callable[[E], N]) -> 'MyClass[N, E]':
            return MyClass(function(self.error), self.error)
  out: |
    main:14: error: Argument 1 of "map" is incompatible with supertype "Functor"; supertype defines the argument type as "Callable[[V], _NewValueType]"
    main:14: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
    main:14: note: This violates the Liskov substitution principle
